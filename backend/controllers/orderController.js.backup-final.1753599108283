const { query, transaction } = require('../config/database');

// Obtener todos los pedidos con filtros
const getOrders = async (req, res) => {
  try {
    const { 
      page = 1, 
      limit = 10, 
      status, 
      dateFrom, 
      dateTo, 
      search,
      sortBy = 'created_at',
      sortOrder = 'DESC'
    } = req.query;
    
    const offset = (page - 1) * limit;
    const userRole = req.user.role;
    const userId = req.user.id;

    // Construir query base con filtros seg√∫n el rol
    let whereClause = 'WHERE 1=1';
    const params = [];

    // Filtros por rol - Admin solo puede ver para informes, no gestionar
    if (userRole === 'mensajero') {
      whereClause += ' AND (o.status IN ("en_reparto", "entregado_transportadora") OR o.assigned_to = ?)';
      params.push(userId);
    } else if (userRole === 'logistica') {
      // Log√≠stica puede ver pedidos en su fase y tambi√©n en empaque ya que supervisan ese proceso
      whereClause += ' AND o.status IN ("en_logistica", "en_preparacion", "listo", "en_empaque", "empacado")';
    } else if (userRole === 'empaque') {
      // Rol espec√≠fico de empaque (si existiera) - pero empaque usa rol logistica
      whereClause += ' AND o.status IN ("en_empaque", "empacado")';
    } else if (userRole === 'cartera') {
      whereClause += ' AND o.status = "revision_cartera"';
    } else if (userRole === 'facturador') {
      whereClause += ' AND o.status = "pendiente_por_facturacion"';
    } else if (userRole === 'admin') {
      // Admin puede ver todos los pedidos solo para informes, sin filtros restrictivos
      // No se agrega filtro adicional - puede ver todo para generar reportes
      
      // Solo para admin: aplicar filtro de estado adicional si se proporciona
      if (status) {
        whereClause += ' AND o.status = ?';
        params.push(status);
      }
    }

    // Para roles espec√≠ficos, ignorar el filtro de estado adicional ya que tienen su propio filtro por rol
    // Solo el admin puede filtrar por estado libremente

    if (dateFrom) {
      whereClause += ' AND DATE(o.created_at) >= ?';
      params.push(dateFrom);
    }

    if (dateTo) {
      whereClause += ' AND DATE(o.created_at) <= ?';
      params.push(dateTo);
    }

    if (search) {
      whereClause += ' AND (o.customer_name LIKE ? OR o.customer_phone LIKE ? OR o.order_number LIKE ?)';
      const searchTerm = `%${search}%`;
      params.push(searchTerm, searchTerm, searchTerm);
    }

    // Validar campos de ordenamiento
    const validSortFields = ['created_at', 'order_number', 'customer_name', 'status', 'total_amount'];
    const validSortOrders = ['ASC', 'DESC'];
    
    const orderBy = validSortFields.includes(sortBy) ? sortBy : 'created_at';
    const order = validSortOrders.includes(sortOrder.toUpperCase()) ? sortOrder.toUpperCase() : 'DESC';

    // Obtener pedidos con informaci√≥n del usuario creador
    const orders = await query(
      `SELECT 
        o.id, o.order_number, o.customer_name, o.customer_phone, o.customer_address, 
        o.customer_email, o.status, o.total_amount, o.notes, o.shipping_date,
        o.payment_method, o.delivery_method, o.created_at, o.updated_at,
        o.siigo_invoice_id, o.siigo_invoice_number, o.siigo_public_url, o.siigo_customer_id,
        o.siigo_observations, o.siigo_payment_info, o.siigo_seller_id, o.siigo_balance,
        o.siigo_document_type, o.siigo_stamp_status, o.siigo_mail_status,
        u.full_name as created_by_name,
        assigned_user.full_name as assigned_to_name
       FROM orders o
       LEFT JOIN users u ON o.created_by = u.id
       LEFT JOIN users assigned_user ON o.assigned_to = assigned_user.id
       ${whereClause}
       ORDER BY o.${orderBy} ${order}
       LIMIT ? OFFSET ?`,
      [...params, parseInt(limit), offset]
    );

    // Obtener items de cada pedido
    for (let order of orders) {
      const items = await query(
        'SELECT id, name, quantity, price, description FROM order_items WHERE order_id = ?',
        [order.id]
      );
      order.items = items;
    }

    // Obtener total para paginaci√≥n
    const totalResult = await query(
      `SELECT COUNT(*) as total FROM orders o ${whereClause}`,
      params
    );
    const total = totalResult[0].total;

    res.json({
      success: true,
      data: {
        orders,
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total,
          pages: Math.ceil(total / limit)
        }
      }
    });

  } catch (error) {
    console.error('Error obteniendo pedidos:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
};

// Obtener pedido por ID
const getOrderById = async (req, res) => {
  try {
    const { id } = req.validatedParams;

    // Obtener pedido
    const orders = await query(
      `SELECT 
        o.*, 
        u.full_name as created_by_name,
        assigned_user.full_name as assigned_to_name
       FROM orders o
       LEFT JOIN users u ON o.created_by = u.id
       LEFT JOIN users assigned_user ON o.assigned_to = assigned_user.id
       WHERE o.id = ?`,
      [id]
    );

    if (!orders.length) {
      return res.status(404).json({
        success: false,
        message: 'Pedido no encontrado'
      });
    }

    const order = orders[0];

    // Obtener items del pedido
    const items = await query(
      'SELECT id, name, quantity, price, description FROM order_items WHERE order_id = ?',
      [id]
    );

    order.items = items;

    res.json({
      success: true,
      data: order
    });

  } catch (error) {
    console.error('Error obteniendo pedido:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
};

// Crear nuevo pedido
const createOrder = async (req, res) => {
  try {
    console.log('Datos recibidos en createOrder:', JSON.stringify(req.body, null, 2));
    
    const { 
      invoiceCode,
      customerName, 
      customerPhone, 
      customerAddress, 
      customerEmail,
      customerDepartment,
      customerCity,
      deliveryMethod,
      paymentMethod,
      items, 
      notes, 
      deliveryDate,
      totalAmount 
    } = req.body;

    const userId = req.user.id;

    // Validaciones b√°sicas con logs detallados
    const missingFields = [];
    if (!customerName) missingFields.push('customerName');
    if (!customerPhone) missingFields.push('customerPhone');
    if (!customerAddress) missingFields.push('customerAddress');
    if (!customerDepartment) missingFields.push('customerDepartment');
    if (!customerCity) missingFields.push('customerCity');

    if (missingFields.length > 0) {
      console.log('Campos faltantes:', missingFields);
      return res.status(400).json({
        success: false,
        message: `Faltan campos obligatorios: ${missingFields.join(', ')}`,
        missingFields
      });
    }

    if (!items || items.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Debe incluir al menos un item'
      });
    }

    // Generar n√∫mero de pedido √∫nico
    const orderNumber = `ORD-${Date.now()}-${Math.random().toString(36).substr(2, 5).toUpperCase()}`;

    // Calcular total si no se proporciona
    const calculatedTotal = totalAmount || items.reduce((sum, item) => sum + (item.quantity * item.price), 0);

    // Determinar estado inicial seg√∫n reglas de negocio
    let initialStatus = 'pendiente_facturacion';
    if (deliveryMethod === 'recogida_tienda' && paymentMethod !== 'efectivo') {
      initialStatus = 'revision_cartera'; // Requiere verificaci√≥n de pago
    } else if (deliveryMethod === 'domicilio_ciudad' && paymentMethod === 'efectivo') {
      initialStatus = 'en_logistica'; // Pasa directo a log√≠stica
    }

    const result = await transaction(async (connection) => {
      // Crear pedido
      const [orderResult] = await connection.execute(
        `INSERT INTO orders (
          order_number, invoice_code, customer_name, customer_phone, customer_address, 
          customer_email, customer_department, customer_city, delivery_method, payment_method,
          status, total_amount, notes, shipping_date, created_by, created_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())`,
        [
          orderNumber, 
          invoiceCode || null,
          customerName, 
          customerPhone, 
          customerAddress, 
          customerEmail || null,
          customerDepartment,
          customerCity,
          deliveryMethod || 'domicilio_ciudad',
          paymentMethod || 'efectivo',
          initialStatus,
          calculatedTotal, 
          notes || null, 
          deliveryDate || null, 
          userId
        ]
      );

      const orderId = orderResult.insertId;

      // Crear items del pedido
      for (const item of items) {
        if (item.name && item.quantity > 0 && item.price >= 0) {
          await connection.execute(
            'INSERT INTO order_items (order_id, name, quantity, price, description) VALUES (?, ?, ?, ?, ?)',
            [orderId, item.name, item.quantity, item.price, item.description || null]
          );
        }
      }

      return orderId;
    });

    // Obtener el pedido creado completo
    const newOrder = await query(
      `SELECT 
        o.*, 
        u.full_name as created_by_name
       FROM orders o
       LEFT JOIN users u ON o.created_by = u.id
       WHERE o.id = ?`,
      [result]
    );

    const orderItems = await query(
      'SELECT id, name, quantity, price, description FROM order_items WHERE order_id = ?',
      [result]
    );

    newOrder[0].items = orderItems;

    res.status(201).json({
      success: true,
      message: 'Pedido creado exitosamente',
      data: newOrder[0]
    });

  } catch (error) {
    console.error('Error creando pedido:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
};


// Actualizar pedido
const updateOrder = async (req, res) => {
  try {
    // üîç LOGGING DETALLADO PARA SHIPPING_DATE - INICIO
    console.log('\n' + '='.repeat(80));
    console.log('üîç ORDER UPDATE REQUEST - SHIPPING_DATE LOGGING');
    console.log('='.repeat(80));
    console.log('‚è∞ Timestamp:', new Date().toISOString());
    console.log('üë§ User:', req.user?.username || 'unknown');
    console.log('üÜî User Role:', req.user?.role || 'unknown');
    console.log('');
    
    // Log de par√°metros de la request
    console.log('üìù REQUEST PARAMETERS:');
    console.log('   Order ID:', req.validatedParams?.id || req.params?.id || 'MISSING');
    console.log('');
    
    // Log detallado del body de la request
    console.log('üì¶ REQUEST BODY (RAW):');
    console.log('   Body keys:', Object.keys(req.body || {}));
    console.log('   Body content:', JSON.stringify(req.body, null, 2));
    console.log('');
    
    // Log espec√≠fico para campos cr√≠ticos
    console.log('üîç CRITICAL FIELDS ANALYSIS:');
    console.log('   ‚úÖ payment_method:', req.body?.payment_method || 'MISSING');
    console.log('   üö® shipping_date:', req.body?.shipping_date || 'MISSING');
    console.log('   üìù notes:', req.body?.notes || 'MISSING');
    console.log('   üéØ action:', req.body?.action || 'MISSING');
    console.log('   üÜî orderId:', req.body?.orderId || 'MISSING');
    console.log('');
    
    // Verificar si shipping_date est√° presente
    if (req.body?.shipping_date) {
      console.log('‚úÖ SHIPPING_DATE FOUND IN REQUEST:');
      console.log('   Value:', req.body.shipping_date);
      console.log('   Type:', typeof req.body.shipping_date);
      console.log('   Length:', req.body.shipping_date.length);
      console.log('   Is valid date?', !isNaN(Date.parse(req.body.shipping_date)));
    } else {
      console.log('üö® WARNING: SHIPPING_DATE NOT FOUND IN REQUEST BODY');
      console.log('   This may be the source of the problem!');
    }
    console.log('');
    
    // Log de validatedData si existe
    if (req.validatedData) {
      console.log('‚úÖ VALIDATED DATA:');
      console.log('   Keys:', Object.keys(req.validatedData));
      console.log('   shipping_date in validated:', req.validatedData.shipping_date || 'MISSING');
      console.log('   Content:', JSON.stringify(req.validatedData, null, 2));
    } else {
      console.log('‚ö†Ô∏è  No validated data found');
    }
    console.log('');
    // üîç LOGGING DETALLADO PARA SHIPPING_DATE - FIN
    
    const { id } = req.validatedParams;
    const updateData = req.validatedData;
    const userRole = req.user.role;

    // Verificar que el pedido existe
    const existingOrder = await query('SELECT * FROM orders WHERE id = ?', [id]);
    
    if (!existingOrder.length) {
      return res.status(404).json({
        success: false,
        message: 'Pedido no encontrado'
      });
    }

    const order = existingOrder[0];

    // Validar permisos seg√∫n el rol y estado del pedido
    if (userRole === 'mensajero' && !['enviado', 'entregado'].includes(updateData.status)) {
      return res.status(403).json({
        success: false,
        message: 'Los mensajeros solo pueden actualizar pedidos enviados a entregados'
      });
    }

    if (userRole === 'logistica' && order.status === 'entregado') {
      return res.status(403).json({
        success: false,
        message: 'No se pueden modificar pedidos ya entregados'
      });
    }

    await transaction(async (connection) => {
      // Actualizar pedido
      const updateFields = [];
      const updateValues = [];

      
      // üîç FIELD MAPPING LOGGING - INICIO
      console.log('üîß FIELD MAPPING PROCESS:');
      console.log('   Processing', Object.keys(updateData).length, 'fields');
      console.log('');
      
      Object.keys(updateData).forEach(key => {
        if (!['items'].includes(key)) {
          const dbField = key === 'customerName' ? 'customer_name' :
                         key === 'customerPhone' ? 'customer_phone' :
                         key === 'customerAddress' ? 'customer_address' :
                         key === 'customerEmail' ? 'customer_email' :
                         key === 'deliveryDate' ? 'delivery_date' :
                         key === 'shippingDate' ? 'shipping_date' : key;
          
          console.log('   üîß Mapping:', key, '->', dbField, '=', '"' + updateData[key] + '"');
          
          // Especial atenci√≥n a shipping_date
          if (key === 'shipping_date' || key === 'shippingDate') {
            console.log('   üö® SHIPPING_DATE FIELD DETECTED:');
            console.log('      Original key:', key);
            console.log('      Mapped to:', dbField);
            console.log('      Value:', updateData[key]);
            console.log('      Will be included in UPDATE:', true);
          }
          
          updateFields.push(`${dbField} = ?`);
          updateValues.push(updateData[key]);
        }
      });
      
      console.log('');
      console.log('üìä FINAL UPDATE ARRAYS:');
      console.log('   Update fields:', updateFields);
      console.log('   Update values:', updateValues);
      console.log('');
      
      // Verificar si shipping_date est√° en los campos finales
      const shippingFieldIndex = updateFields.findIndex(field => field.includes('shipping_date'));
      if (shippingFieldIndex >= 0) {
        console.log('‚úÖ SHIPPING_DATE IN FINAL UPDATE:');
        console.log('   Field:', updateFields[shippingFieldIndex]);
        console.log('   Value:', updateValues[shippingFieldIndex]);
        console.log('   Index:', shippingFieldIndex);
      } else {
        console.log('üö® ERROR: SHIPPING_DATE NOT IN FINAL UPDATE ARRAYS');
        console.log('   This explains why the date is not being saved!');
      }
      console.log('');
      // üîç FIELD MAPPING LOGGING - FIN

      
      // üîß CORREGIDO: Mapeo √∫nico de campos (eliminada duplicaci√≥n)
      // üîß CORREGIDO: Mapeo √∫nico de campos (eliminada duplicaci√≥n)
      Object.keys(updateData).forEach(key => {
        if (key !== 'items' && updateData[key] !== undefined) {
          const dbField = key === 'customerName' ? 'customer_name' :
                         key === 'customerPhone' ? 'customer_phone' :
                         key === 'customerAddress' ? 'customer_address' :
                         key === 'customerEmail' ? 'customer_email' :
                         key === 'deliveryDate' ? 'delivery_date' :
                         key === 'shippingDate' ? 'shipping_date' : 
                         key; // Para shipping_date directo del frontend
          
          console.log('   ‚úÖ Mapping corregido:', key, '->', dbField, '=', '"' + updateData[key] + '"');
          
          updateFields.push(`${dbField} = ?`);
          updateValues.push(updateData[key]);
        }
      });

      if (updateFields.length > 0) {
        updateFields.push('updated_at = NOW()');
        updateValues.push(id);

        
      // üîç SQL EXECUTION LOGGING - INICIO
      console.log('üîß EXECUTING SQL UPDATE:');
      console.log('   Query:', `UPDATE orders SET ${updateFields.join(', ')} WHERE id = ?`);
      console.log('   Values:', updateValues);
      console.log('   Order ID:', id);
      console.log('');
      
      // Verificaci√≥n final de shipping_date
      const finalShippingIndex = updateFields.findIndex(f => f.includes('shipping_date'));
      if (finalShippingIndex >= 0) {
        console.log('‚úÖ FINAL SHIPPING_DATE CHECK:');
        console.log('   SQL field:', updateFields[finalShippingIndex]);
        console.log('   SQL value:', updateValues[finalShippingIndex]);
      } else {
        console.log('üö® FINAL WARNING: NO SHIPPING_DATE IN SQL');
      }
      console.log('');
      // üîç SQL EXECUTION LOGGING - FIN
      
        
        const updateResult = await connection.execute(
          `UPDATE orders SET ${updateFields.join(', ')} WHERE id = ?`,
          updateValues
        );
        
        // üîç UPDATE RESULT LOGGING
        console.log('üìä UPDATE RESULT:');
        console.log('   Affected rows:', updateResult.affectedRows);
        console.log('   Changed rows:', updateResult.changedRows);
        console.log('   Warnings:', updateResult.warningCount);
        console.log('');
      }

      // NUEVO FLUJO OBLIGATORIO: Log√≠stica -> Empaque -> Reparto
      if (updateData.status === 'listo' && userRole === 'logistica') {
        // Cuando log√≠stica marca como "listo", debe ir obligatoriamente a empaque
        updateData.status = 'pendiente_empaque';
        console.log('üîÑ Pedido enviado autom√°ticamente a empaque para verificaci√≥n');
      }

      // Registrar en caja si es recogida en tienda + efectivo + va a log√≠stica
      if (updateData.delivery_method === 'recogida_tienda' && 
          updateData.payment_method === 'efectivo' && 
          updateData.status === 'en_logistica') {
        
        console.log('üí∞ Registrando dinero en efectivo para cierre de caja...');
        
        // Verificar si ya existe un registro para este pedido
        const existingCashRegister = await connection.execute(
          'SELECT id FROM cash_register WHERE order_id = ?',
          [id]
        );

        if (existingCashRegister[0].length === 0) {
          // Registrar el dinero en efectivo
          await connection.execute(
            `INSERT INTO cash_register (
              order_id, amount, payment_method, delivery_method, 
              registered_by, notes, created_at
            ) VALUES (?, ?, ?, ?, ?, ?, NOW())`,
            [
              id,
              order.total_amount,
              updateData.payment_method,
              updateData.delivery_method,
              req.user.id,
              `Recogida en bodega - Registrado autom√°ticamente por ${req.user.full_name || req.user.username}`
            ]
          );

          console.log(`‚úÖ Dinero registrado en caja: $${order.total_amount} - Pedido ${order.order_number}`);
        }
      }

      // Actualizar items si se proporcionan
      if (updateData.items) {
        // Eliminar items existentes
        await connection.execute('DELETE FROM order_items WHERE order_id = ?', [id]);

        // Crear nuevos items
        let totalAmount = 0;
        for (const item of updateData.items) {
          await connection.execute(
            'INSERT INTO order_items (order_id, name, quantity, price, description) VALUES (?, ?, ?, ?, ?)',
            [id, item.name, item.quantity, item.price, item.description || null]
          );
          totalAmount += item.quantity * item.price;
        }

        // Actualizar total
        await connection.execute(
          'UPDATE orders SET total_amount = ? WHERE id = ?',
          [totalAmount, id]
        );
      }

      // Si se asigna a mensajero, actualizar assigned_to
      if (updateData.status === 'enviado' && userRole === 'logistica') {
        // Aqu√≠ podr√≠as implementar l√≥gica para asignar autom√°ticamente a un mensajero
        // Por ahora lo dejamos como null para asignaci√≥n manual posterior
      }
    });

    // Obtener pedido actualizado
    const updatedOrder = await query(
      `SELECT 
        o.*, 
        u.full_name as created_by_name,
        assigned_user.full_name as assigned_to_name
       FROM orders o
       LEFT JOIN users u ON o.created_by = u.id
       LEFT JOIN users assigned_user ON o.assigned_to = assigned_user.id
       WHERE o.id = ?`,
      [id]
    );

    const items = await query(
      'SELECT id, name, quantity, price, description FROM order_items WHERE order_id = ?',
      [id]
    );

    updatedOrder[0].items = items;

    
    // üîç FINAL VERIFICATION LOGGING
    console.log('üîç FINAL ORDER VERIFICATION:');
    const [verificationResult] = await query(
      'SELECT id, order_number, shipping_date, payment_method, status, updated_at FROM orders WHERE id = ?',
      [id]
    );
    
    if (verificationResult.length > 0) {
      const finalOrder = verificationResult[0];
      console.log('   Order:', finalOrder.order_number);
      console.log('   Status:', finalOrder.status);
      console.log('   Payment Method:', finalOrder.payment_method);
      console.log('   üö® Shipping Date:', finalOrder.shipping_date || 'NULL');
      console.log('   Updated At:', finalOrder.updated_at);
      
      if (finalOrder.shipping_date) {
        console.log('‚úÖ SUCCESS: Shipping date was saved successfully!');
      } else {
        console.log('üö® PROBLEM: Shipping date is still NULL after update!');
      }
    }
    
    console.log('='.repeat(80));
    console.log('üîç ORDER UPDATE LOGGING COMPLETE');
    console.log('='.repeat(80) + '\n');
    
      
      res.json({
        success: true,
        message: 'Pedido actualizado exitosamente',
        data: updatedOrder[0]
      });

  } catch (error) {
    console.error('Error actualizando pedido:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
};

// Eliminar pedido (solo admin)
const deleteOrder = async (req, res) => {
  try {
    const { id } = req.validatedParams;

    // Verificar que el pedido existe
    const existingOrder = await query('SELECT id, status FROM orders WHERE id = ?', [id]);
    
    if (!existingOrder.length) {
      return res.status(404).json({
        success: false,
        message: 'Pedido no encontrado'
      });
    }

    // No permitir eliminar pedidos entregados
    if (existingOrder[0].status === 'entregado') {
      return res.status(400).json({
        success: false,
        message: 'No se pueden eliminar pedidos entregados'
      });
    }

    await transaction(async (connection) => {
      // Eliminar items del pedido
      await connection.execute('DELETE FROM order_items WHERE order_id = ?', [id]);
      
      // Eliminar pedido
      await connection.execute('DELETE FROM orders WHERE id = ?', [id]);
    });

    res.json({
      success: true,
      message: 'Pedido eliminado exitosamente'
    });

  } catch (error) {
    console.error('Error eliminando pedido:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
};

// Eliminar pedido de SIIGO (devuelve el pedido a SIIGO para reimportaci√≥n)
const deleteSiigoOrder = async (req, res) => {
  try {
    const { id } = req.validatedParams;

    // Verificar que el pedido existe y tiene informaci√≥n de SIIGO
    const existingOrder = await query(
      'SELECT id, status, siigo_invoice_id, siigo_invoice_number, order_number FROM orders WHERE id = ?', 
      [id]
    );
    
    if (!existingOrder.length) {
      return res.status(404).json({
        success: false,
        message: 'Pedido no encontrado'
      });
    }

    const order = existingOrder[0];

    // Verificar que el pedido proviene de SIIGO
    if (!order.siigo_invoice_id) {
      return res.status(400).json({
        success: false,
        message: 'Solo se pueden eliminar pedidos que provengan de SIIGO'
      });
    }

    // No permitir eliminar pedidos entregados
    if (['entregado_cliente', 'entregado_transportadora'].includes(order.status)) {
      return res.status(400).json({
        success: false,
        message: 'No se pueden eliminar pedidos ya entregados'
      });
    }

    // Helper para verificar si una tabla existe
    const tableExists = async (connection, tableName) => {
      try {
        const [result] = await connection.execute(
          `SELECT 1 FROM information_schema.tables 
           WHERE table_schema = DATABASE() AND table_name = ?`,
          [tableName]
        );
        return result.length > 0;
      } catch (error) {
        return false;
      }
    };

    // Helper seguro para eliminar de una tabla si existe
    const safeDelete = async (connection, tableName, whereClause, params) => {
      try {
        if (await tableExists(connection, tableName)) {
          const [result] = await connection.execute(`DELETE FROM ${tableName} WHERE ${whereClause}`, params);
          console.log(`   ‚úÖ ${result.affectedRows} registros eliminados de ${tableName}`);
          return result.affectedRows;
        } else {
          console.log(`   ‚ö†Ô∏è Tabla ${tableName} no existe, saltando...`);
          return 0;
        }
      } catch (error) {
        console.log(`   ‚ùå Error eliminando de ${tableName}:`, error.message);
        return 0;
      }
    };

    await transaction(async (connection) => {
      console.log(`üóëÔ∏è Eliminando pedido SIIGO: ${order.order_number} (ID: ${order.siigo_invoice_id})`);
      
      // 1. Eliminar items del pedido (tabla requerida)
      console.log('  1. Eliminando items del pedido...');
      const [itemsResult] = await connection.execute('DELETE FROM order_items WHERE order_id = ?', [id]);
      console.log(`   ‚úÖ ${itemsResult.affectedRows} items eliminados`);
      
      // 2. Eliminar registros relacionados opcionales
      console.log('  2. Eliminando registros relacionados...');
      await safeDelete(connection, 'cash_register', 'order_id = ?', [id]);
      await safeDelete(connection, 'packaging_records', 'order_id = ?', [id]);
      await safeDelete(connection, 'shipping_guides', 'order_id = ?', [id]);
      await safeDelete(connection, 'wallet_validations', 'order_id = ?', [id]);
      await safeDelete(connection, 'logistics_records', 'order_id = ?', [id]);
      
      // 3. Eliminar de la tabla de sincronizaci√≥n de SIIGO si existe para permitir reimportaci√≥n
      console.log('  3. Eliminando sincronizaci√≥n SIIGO...');
      await safeDelete(connection, 'siigo_sync_log', 'invoice_id = ?', [order.siigo_invoice_id]);
      
      // 4. Eliminar el pedido principal
      console.log('  4. Eliminando pedido principal...');
      const [orderResult] = await connection.execute('DELETE FROM orders WHERE id = ?', [id]);
      console.log(`   ‚úÖ ${orderResult.affectedRows} pedido eliminado`);
      
      console.log(`‚úÖ Pedido ${order.order_number} eliminado exitosamente y disponible para reimportaci√≥n desde SIIGO`);
    });

    res.json({
      success: true,
      message: `Pedido eliminado exitosamente. La factura ${order.siigo_invoice_number || order.siigo_invoice_id} volver√° a estar disponible para importar desde SIIGO.`
    });

  } catch (error) {
    console.error('Error eliminando pedido SIIGO:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
};

// Asignar pedido a mensajero
const assignOrder = async (req, res) => {
  try {
    const { id } = req.validatedParams;
    const { messengerId } = req.body;

    // Verificar que el pedido existe y est√° listo para env√≠o
    const order = await query('SELECT id, status FROM orders WHERE id = ?', [id]);
    
    if (!order.length) {
      return res.status(404).json({
        success: false,
        message: 'Pedido no encontrado'
      });
    }

    if (order[0].status !== 'listo') {
      return res.status(400).json({
        success: false,
        message: 'Solo se pueden asignar pedidos que est√©n listos'
      });
    }

    // Verificar que el mensajero existe
    const messenger = await query(
      'SELECT id FROM users WHERE id = ? AND role = "mensajero" AND active = true',
      [messengerId]
    );

    if (!messenger.length) {
      return res.status(400).json({
        success: false,
        message: 'Mensajero no v√°lido'
      });
    }

    // Asignar pedido y cambiar estado
    await query(
      'UPDATE orders SET assigned_to = ?, status = "enviado", updated_at = NOW() WHERE id = ?',
      [messengerId, id]
    );

    res.json({
      success: true,
      message: 'Pedido asignado exitosamente'
    });

  } catch (error) {
    console.error('Error asignando pedido:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
};

// Obtener estad√≠sticas de pedidos
const getOrderStats = async (req, res) => {
  try {
    const { dateFrom, dateTo } = req.query;
    const userRole = req.user.role;
    const userId = req.user.id;

    let whereClause = 'WHERE 1=1';
    const params = [];

    // Filtros por rol
    if (userRole === 'mensajero') {
      whereClause += ' AND assigned_to = ?';
      params.push(userId);
    }

    if (dateFrom) {
      whereClause += ' AND DATE(created_at) >= ?';
      params.push(dateFrom);
    }

    if (dateTo) {
      whereClause += ' AND DATE(created_at) <= ?';
      params.push(dateTo);
    }

    // Estad√≠sticas por estado
    const statusStats = await query(
      `SELECT status, COUNT(*) as count, SUM(total_amount) as total_amount 
       FROM orders ${whereClause} 
       GROUP BY status`,
      params
    );

    // Total general
    const totalStats = await query(
      `SELECT COUNT(*) as total_orders, SUM(total_amount) as total_revenue 
       FROM orders ${whereClause}`,
      params
    );

    // Pedidos por d√≠a (√∫ltimos 7 d√≠as)
    const dailyStats = await query(
      `SELECT DATE(created_at) as date, COUNT(*) as count 
       FROM orders ${whereClause} AND created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY)
       GROUP BY DATE(created_at) 
       ORDER BY date DESC`,
      params
    );

    res.json({
      success: true,
      data: {
        statusStats,
        totalStats: totalStats[0],
        dailyStats
      }
    });

  } catch (error) {
    console.error('Error obteniendo estad√≠sticas:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
};

// Obtener estad√≠sticas avanzadas del dashboard
const getDashboardStats = async (req, res) => {
  try {
    const userRole = req.user.role;
    const userId = req.user.id;

    let whereClause = 'WHERE 1=1';
    const params = [];

    // Filtros por rol
    if (userRole === 'mensajero') {
      whereClause += ' AND assigned_to = ?';
      params.push(userId);
    }

    // Estad√≠sticas por estado con iconos y colores
    const statusStats = await query(
      `SELECT 
        status,
        COUNT(*) as count,
        SUM(total_amount) as total_amount,
        CASE 
          WHEN status = 'pendiente_facturacion' THEN 'file-text'
          WHEN status = 'revision_cartera' THEN 'credit-card'
          WHEN status = 'en_logistica' THEN 'package'
          WHEN status = 'en_reparto' THEN 'truck'
          WHEN status = 'entregado_transportadora' THEN 'send'
          WHEN status = 'entregado_cliente' THEN 'check'
          WHEN status = 'cancelado' THEN 'x-circle'
          ELSE 'circle'
        END as icon,
        CASE 
          WHEN status = 'pendiente_facturacion' THEN 'warning'
          WHEN status = 'revision_cartera' THEN 'info'
          WHEN status = 'en_logistica' THEN 'primary'
          WHEN status = 'en_reparto' THEN 'primary'
          WHEN status = 'entregado_transportadora' THEN 'success'
          WHEN status = 'entregado_cliente' THEN 'success'
          WHEN status = 'cancelado' THEN 'danger'
          ELSE 'secondary'
        END as color
       FROM orders ${whereClause} 
       GROUP BY status
       ORDER BY 
         CASE status
           WHEN 'pendiente_facturacion' THEN 1
           WHEN 'revision_cartera' THEN 2
           WHEN 'en_logistica' THEN 3
           WHEN 'en_reparto' THEN 4
           WHEN 'entregado_transportadora' THEN 5
           WHEN 'entregado_cliente' THEN 6
           WHEN 'cancelado' THEN 7
         END`,
      params
    );

    // M√©tricas financieras
    const todayRevenue = await query(
      `SELECT COALESCE(SUM(total_amount), 0) as amount 
       FROM orders ${whereClause} AND DATE(created_at) = CURDATE()`,
      params
    );

    const moneyInTransit = await query(
      `SELECT COALESCE(SUM(total_amount), 0) as amount 
       FROM orders ${whereClause} AND status = 'enviado'`,
      params
    );

    const averageOrderValue = await query(
      `SELECT COALESCE(AVG(total_amount), 0) as amount 
       FROM orders ${whereClause} AND created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)`,
      params
    );

    // Evoluci√≥n de pedidos por d√≠as (√∫ltimos 14 d√≠as)
    const dailyEvolution = await query(
      `SELECT 
        DATE(created_at) as date,
        COUNT(*) as count,
        SUM(total_amount) as revenue
       FROM orders ${whereClause} AND created_at >= DATE_SUB(NOW(), INTERVAL 14 DAY)
       GROUP BY DATE(created_at) 
       ORDER BY date ASC`,
      params
    );

    // Pedidos por m√©todo de entrega
    const deliveryMethodStats = await query(
      `SELECT 
        COALESCE(delivery_method, 'domicilio') as method,
        COUNT(*) as count,
        SUM(total_amount) as total_amount
       FROM orders ${whereClause}
       GROUP BY delivery_method`,
      params
    );

    // Ingresos acumulados por semana (√∫ltimas 8 semanas)
    const weeklyRevenue = await query(
      `SELECT 
        YEARWEEK(created_at) as week,
        SUM(total_amount) as revenue,
        COUNT(*) as orders
       FROM orders ${whereClause} AND created_at >= DATE_SUB(NOW(), INTERVAL 8 WEEK)
       GROUP BY YEARWEEK(created_at) 
       ORDER BY week ASC`,
      params
    );

    // Rendimiento por mensajero (solo para admin y log√≠stica)
    let messengerPerformance = [];
    if (['admin', 'logistica'].includes(userRole)) {
      messengerPerformance = await query(
        `SELECT 
          u.full_name,
          COUNT(o.id) as assigned_orders,
          SUM(CASE WHEN o.status = 'entregado' THEN 1 ELSE 0 END) as delivered_orders,
          ROUND((SUM(CASE WHEN o.status = 'entregado' THEN 1 ELSE 0 END) / COUNT(o.id)) * 100, 2) as efficiency
         FROM users u
         LEFT JOIN orders o ON u.id = o.assigned_to AND o.created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
         WHERE u.role = 'mensajero' AND u.active = true
         GROUP BY u.id, u.full_name
         HAVING assigned_orders > 0
         ORDER BY efficiency DESC`,
        []
      );
    }

    // Alertas inteligentes
    const alerts = [];

    // Pedidos retrasados (m√°s de 2 d√≠as en el mismo estado)
    const delayedOrders = await query(
      `SELECT COUNT(*) as count 
       FROM orders ${whereClause} 
       AND status NOT IN ('entregado', 'cancelado') 
       AND updated_at < DATE_SUB(NOW(), INTERVAL 2 DAY)`,
      params
    );

    if (delayedOrders[0].count > 0) {
      alerts.push({
        type: 'warning',
        title: 'Pedidos Retrasados',
        message: `${delayedOrders[0].count} pedidos llevan m√°s de 2 d√≠as sin actualizar`,
        action: 'Ver Pedidos',
        actionUrl: '/orders?filter=delayed'
      });
    }

    // Dinero pendiente con mensajeros
    if (moneyInTransit[0].amount > 0) {
      alerts.push({
        type: 'info',
        title: 'Dinero en Tr√°nsito',
        message: `$${moneyInTransit[0].amount.toLocaleString()} pendiente con mensajeros`,
        action: 'Ver Detalles',
        actionUrl: '/orders?status=enviado'
      });
    }

    // Capacidad alta (m√°s de 20 pedidos pendientes)
    const pendingCount = statusStats.find(s => s.status === 'pendiente')?.count || 0;
    if (pendingCount > 20) {
      alerts.push({
        type: 'danger',
        title: 'Alta Demanda',
        message: `${pendingCount} pedidos pendientes requieren atenci√≥n`,
        action: 'Procesar',
        actionUrl: '/orders?status=pendiente'
      });
    }

    // Estad√≠sticas espec√≠ficas para las tarjetas principales
    const totalOrders = await query(
      `SELECT COUNT(*) as count FROM orders ${whereClause}`,
      params
    );

    const pendingPayment = await query(
      `SELECT COUNT(*) as count FROM orders ${whereClause} AND status = 'revision_cartera'`,
      params
    );

    const pendingLogistics = await query(
      `SELECT COUNT(*) as count FROM orders ${whereClause} AND status IN ('en_logistica', 'en_preparacion')`,
      params
    );

    const pendingPackaging = await query(
      `SELECT COUNT(*) as count FROM orders ${whereClause} AND status IN ('pendiente_empaque', 'en_empaque')`,
      params
    );

    const pendingDelivery = await query(
      `SELECT COUNT(*) as count FROM orders ${whereClause} AND status IN ('en_reparto', 'entregado_transportadora')`,
      params
    );

    const delivered = await query(
      `SELECT COUNT(*) as count FROM orders ${whereClause} AND status = 'entregado_cliente'`,
      params
    );

    res.json({
      success: true,
      data: {
        // Estad√≠sticas principales para las tarjetas
        totalOrders: totalOrders[0].count,
        pendingPayment: pendingPayment[0].count,
        pendingLogistics: pendingLogistics[0].count,
        pendingPackaging: pendingPackaging[0].count,
        pendingDelivery: pendingDelivery[0].count,
        delivered: delivered[0].count,
        
        // Estad√≠sticas existentes
        statusStats,
        financialMetrics: {
          todayRevenue: todayRevenue[0].amount,
          moneyInTransit: moneyInTransit[0].amount,
          averageOrderValue: averageOrderValue[0].amount
        },
        charts: {
          dailyEvolution,
          deliveryMethodStats,
          weeklyRevenue
        },
        performance: {
          messengerPerformance
        },
        alerts
      }
    });

  } catch (error) {
    console.error('Error obteniendo estad√≠sticas del dashboard:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
};

module.exports = {
  getOrders,
  getOrderById,
  createOrder,
  updateOrder,
  deleteOrder,
  deleteSiigoOrder,
  assignOrder,
  getOrderStats,
  getDashboardStats
};
